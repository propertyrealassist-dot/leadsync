const express = require('express');
const router = express.Router();
const { db } = require('../config/database');
const { v4: uuidv4 } = require('uuid');
const { authenticateToken } = require('../middleware/auth');

// Get all templates
router.get('/', authenticateToken, async (req, res) => {
  try {
    console.log('üìã Loading templates for user:', req.user.id);

    const templates = await db.all('SELECT * FROM templates WHERE user_id = ? ORDER BY created_at DESC', [req.user.id]);

    console.log('‚úÖ Found', templates.length, 'templates');
    res.json(templates);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get single template with all related data
router.get('/:id', authenticateToken, async (req, res) => {
  try {
    const template = await db.get('SELECT * FROM templates WHERE id = ? AND user_id = ?', [req.params.id, req.user.id]);

    if (!template) {
      return res.status(404).json({ error: 'Template not found' });
    }

    // Fetch nested data
    const faqs = await db.all('SELECT * FROM faqs WHERE template_id = ?', [req.params.id]);
    const qualificationQuestions = await db.all('SELECT * FROM qualification_questions WHERE template_id = ?', [req.params.id]);
    const followUps = await db.all('SELECT * FROM follow_ups WHERE template_id = ?', [req.params.id]);
    const customActions = await db.all('SELECT * FROM custom_actions WHERE template_id = ?', [req.params.id]);

    console.log(`üì• GET /api/templates/${req.params.id}`);
    console.log('  FAQs:', faqs.length);
    console.log('  Questions:', qualificationQuestions.length);
    console.log('  Follow-ups:', followUps.length);

    // Map database fields to frontend expected format
    template.faqs = faqs.map(f => ({
      id: f.id,
      question: f.question,
      answer: f.answer,
      delay: f.delay,
      expanded: false
    }));

    template.qualificationQuestions = qualificationQuestions.map(q => {
      let conditions = [];
      try {
        conditions = q.conditions ? JSON.parse(q.conditions) : [];
      } catch (e) {
        conditions = [];
      }
      return {
        id: q.id,
        text: q.text,
        conditions: conditions,
        delay: q.delay
      };
    });

    template.followUps = followUps.map(f => ({
      id: f.id,
      text: f.body,  // Map 'body' to 'text' for frontend
      delay: f.delay
    }));

    template.customActions = customActions;

    // Map snake_case database fields to camelCase for frontend
    template.initialMessage = template.initial_message;
    template.companyInformation = template.company_information;
    template.botTemperature = template.bot_temperature;
    template.bookingReadiness = template.booking_readiness;
    template.messageDelayInitial = template.message_delay_initial;
    template.messageDelayStandard = template.message_delay_standard;

    console.log('  ‚úÖ Returning template with nested data');
    res.json(template);
  } catch (error) {
    console.error('‚ùå Error fetching template:', error);
    res.status(500).json({ error: error.message });
  }
});

// Create new template
router.post('/', authenticateToken, (req, res) => {
  console.log('üî• POST /api/templates HIT');
  console.log('üìù Creating template for user:', req.user.id);
  console.log('üì¶ Request body:', JSON.stringify(req.body, null, 2));

  try {
    // Validate required fields
    if (!req.body.name) {
      console.log('‚ùå Validation failed: name is required');
      return res.status(400).json({ error: 'Template name is required' });
    }

    const id = uuidv4();
    console.log('‚ú® Generated template ID:', id);
    const {
      name, tag, botTemperature, brief, resiliancy, bookingReadiness,
      tone, initialMessage, objective, companyInformation,
      messageDelayInitial, messageDelayStandard, cta,
      faqs, qualificationQuestions, followUps, customActions,
      // Support both old and new field names for import compatibility
      goal, context, instructions, qualification_questions, follow_ups, custom_actions, settings
    } = req.body;

    // Map new field names to old field names for backward compatibility
    const mappedBrief = brief || instructions || '';
    const mappedObjective = objective || goal || '';
    const mappedCompanyInfo = companyInformation || context || '';
    const mappedFaqs = faqs || [];
    const mappedQualificationQuestions = qualificationQuestions || qualification_questions || [];
    const mappedFollowUps = followUps || follow_ups || [];
    const mappedCustomActions = customActions || custom_actions;
    const mappedInitialMessage = initialMessage || settings?.initial_message || '';
    const mappedCta = cta || settings?.booking_url || '';
    const mappedMessageDelayStandard = messageDelayStandard || settings?.message_delay || 5;
    const mappedTag = tag || name.toLowerCase().replace(/\s+/g, '-');

    // Use a transaction to ensure all or nothing
    const insertTemplate = db.transaction(() => {
      const stmt = db.prepare(`
        INSERT INTO templates (
          id, user_id, name, tag, bot_temperature, brief, resiliancy, booking_readiness,
          tone, initial_message, objective, company_information,
          message_delay_initial, message_delay_standard, cta
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);

      stmt.run(
      id, req.user.id, name, mappedTag, botTemperature || 0.4, mappedBrief, resiliancy || 3, bookingReadiness || 2,
      tone || 'Friendly and Casual', mappedInitialMessage, mappedObjective, mappedCompanyInfo,
      messageDelayInitial || 30, mappedMessageDelayStandard, mappedCta
    );
    console.log('‚úÖ Template record inserted');

    console.log('üìã Processing nested data...');
    console.log('  FAQs:', mappedFaqs?.length || 0);
    console.log('  Questions:', mappedQualificationQuestions?.length || 0);
    console.log('  Follow-ups:', mappedFollowUps?.length || 0);
    console.log('  Custom Actions:', mappedCustomActions ? (Array.isArray(mappedCustomActions) ? mappedCustomActions.length : Object.keys(mappedCustomActions).length) : 0);

    if (mappedFaqs && mappedFaqs.length > 0) {
      console.log('  Inserting', mappedFaqs.length, 'FAQs...');
      const faqStmt = db.prepare('INSERT INTO faqs (template_id, question, answer, delay) VALUES (?, ?, ?, ?)');
      mappedFaqs.forEach(faq => {
        let question, answer;
        if (typeof faq.Body === 'string' && faq.Body.startsWith('{')) {
          const parsed = JSON.parse(faq.Body);
          question = parsed.question;
          answer = parsed.answer;
        } else {
          question = faq.question;
          answer = faq.answer;
        }
        console.log('    FAQ:', question);
        faqStmt.run(id, question, answer, faq.Delay || faq.delay || 1);
      });
      console.log('  ‚úÖ FAQs inserted');
    }

    if (mappedQualificationQuestions && mappedQualificationQuestions.length > 0) {
      console.log('  Inserting', mappedQualificationQuestions.length, 'qualification questions...');
      const qStmt = db.prepare('INSERT INTO qualification_questions (template_id, text, conditions, delay) VALUES (?, ?, ?, ?)');
      mappedQualificationQuestions.forEach(q => {
        let text;
        if (typeof q.Body === 'string' && q.Body.startsWith('{')) {
          const parsed = JSON.parse(q.Body);
          text = parsed.text;
        } else {
          text = q.text || q.Body;
        }
        console.log('    Question:', text);
        qStmt.run(id, text, JSON.stringify(q.conditions || []), q.Delay || q.delay || 1);
      });
      console.log('  ‚úÖ Questions inserted');
    }

    if (mappedFollowUps && mappedFollowUps.length > 0) {
      console.log('  Inserting', mappedFollowUps.length, 'follow-ups...');
      const fStmt = db.prepare('INSERT INTO follow_ups (template_id, body, delay) VALUES (?, ?, ?)');
      mappedFollowUps.forEach(f => {
        const body = f.Body || f.message || '';
        const delay = f.Delay || f.delay || 1;
        console.log('    Follow-up:', body.substring(0, 50) + '...');
        fStmt.run(id, body, delay);
      });
      console.log('  ‚úÖ Follow-ups inserted');
    }

    if (mappedCustomActions) {
      console.log('  Inserting custom actions...');
      // Handle both object format (old) and array format (new)
      if (Array.isArray(mappedCustomActions)) {
        // New format: array of action objects
        mappedCustomActions.forEach(action => {
          const actionStmt = db.prepare(`
            INSERT INTO custom_actions (template_id, action, rule_condition, description)
            VALUES (?, ?, ?, ?)
          `);
          const actionType = action.type || action.action || 'unknown';
          const ruleCondition = action.rule_condition || action.config?.rule_condition || '';
          const description = action.description || action.config?.description || '';
          const result = actionStmt.run(id, actionType, ruleCondition, description);
          const actionId = result.lastInsertRowid;

          // Handle chains if present
          const chains = action.chains || action.config?.chains;
          if (chains) {
            chains.forEach(chain => {
              const chainStmt = db.prepare(`
                INSERT INTO action_chains (custom_action_id, chain_name, chain_order)
                VALUES (?, ?, ?)
              `);
              const chainResult = chainStmt.run(actionId, chain.chain_name, chain.chain_order);
              const chainId = chainResult.lastInsertRowid;

              if (chain.steps) {
                chain.steps.forEach(step => {
                  db.prepare(`
                    INSERT INTO chain_steps (chain_id, step_order, function, parameters)
                    VALUES (?, ?, ?, ?)
                  `).run(chainId, step.step_order, step.function, JSON.stringify(step.parameters || {}));
                });
              }
            });
          }
        });
      } else {
        // Old format: object with action types as keys
        Object.keys(mappedCustomActions).forEach(actionType => {
          const actions = mappedCustomActions[actionType];
          const actionArray = Array.isArray(actions) ? actions : [actions];
          actionArray.forEach(action => {
            const actionStmt = db.prepare(`
              INSERT INTO custom_actions (template_id, action, rule_condition, description)
              VALUES (?, ?, ?, ?)
            `);
            const result = actionStmt.run(id, actionType, action.rule_condition, action.description || '');
            const actionId = result.lastInsertRowid;

            if (action.chains) {
              action.chains.forEach(chain => {
                const chainStmt = db.prepare(`
                  INSERT INTO action_chains (custom_action_id, chain_name, chain_order)
                  VALUES (?, ?, ?)
                `);
                const chainResult = chainStmt.run(actionId, chain.chain_name, chain.chain_order);
                const chainId = chainResult.lastInsertRowid;

                if (chain.steps) {
                  chain.steps.forEach(step => {
                    db.prepare(`
                      INSERT INTO chain_steps (chain_id, step_order, function, parameters)
                      VALUES (?, ?, ?, ?)
                    `).run(chainId, step.step_order, step.function, JSON.stringify(step.parameters || {}));
                  });
                }
              });
            }
          });
        });
      }
      console.log('  ‚úÖ Custom actions inserted');
    }
    });

    // Execute the transaction
    insertTemplate();

    console.log('‚úÖ Template created successfully with ID:', id);
    res.status(201).json({ id, message: 'Template created successfully' });
  } catch (error) {
    console.log('‚ùå Error creating template:', error.message);
    console.log('‚ùå Stack trace:', error.stack);
    res.status(500).json({ error: error.message });
  }
});

// Update template
router.put('/:id', authenticateToken, (req, res) => {
  console.log('üîÑ PUT /api/templates/:id HIT');
  console.log('‚ôªÔ∏è Updating template for user:', req.user.id);
  console.log('üì¶ Request body keys:', Object.keys(req.body));
  console.log('üìä FAQs in body:', req.body.faqs?.length || 0);
  console.log('üìä Questions in body:', req.body.qualificationQuestions?.length || 0);
  console.log('üìä FollowUps in body:', req.body.followUps?.length || 0);
  if (req.body.faqs && req.body.faqs.length > 0) {
    console.log('üìù First FAQ:', JSON.stringify(req.body.faqs[0]));
  }

  try {
    const {
      name, brief, tone, initialMessage, objective, tag, botTemperature, companyInformation, cta,
      faqs, qualificationQuestions, followUps
    } = req.body;

    const updateTemplate = db.transaction(() => {
      // Update main template fields (only if owned by user)
      db.prepare(`
        UPDATE templates
        SET name = ?, brief = ?, tone = ?, initial_message = ?, objective = ?, tag = ?,
            bot_temperature = ?, company_information = ?, cta = ?, updated_at = CURRENT_TIMESTAMP
        WHERE id = ? AND user_id = ?
      `).run(name, brief, tone, initialMessage, objective, tag, botTemperature, companyInformation, cta, req.params.id, req.user.id);
      console.log('  ‚úÖ Template fields updated');

      // Update nested data if provided
      if (faqs !== undefined) {
        console.log('  Updating', faqs.length, 'FAQs...');
        // Delete existing FAQs
        db.prepare('DELETE FROM faqs WHERE template_id = ?').run(req.params.id);
        // Insert new FAQs
        if (faqs.length > 0) {
          const faqStmt = db.prepare('INSERT INTO faqs (template_id, question, answer, delay) VALUES (?, ?, ?, ?)');
          faqs.forEach(faq => {
            const question = faq.question || '';
            const answer = faq.answer || '';
            const delay = faq.delay || faq.Delay || 1;
            console.log('    Inserting FAQ:', question);
            faqStmt.run(req.params.id, question, answer, delay);
          });
        }
        console.log('  ‚úÖ FAQs updated');
      }

      if (qualificationQuestions !== undefined) {
        console.log('  Updating', qualificationQuestions.length, 'questions...');
        // Delete existing questions
        db.prepare('DELETE FROM qualification_questions WHERE template_id = ?').run(req.params.id);
        // Insert new questions
        if (qualificationQuestions.length > 0) {
          const qStmt = db.prepare('INSERT INTO qualification_questions (template_id, text, conditions, delay) VALUES (?, ?, ?, ?)');
          qualificationQuestions.forEach(q => {
            const text = q.text || q.Body || '';
            const conditions = q.conditions || [];
            const delay = q.delay || q.Delay || 1;
            console.log('    Inserting question:', text);
            qStmt.run(req.params.id, text, JSON.stringify(conditions), delay);
          });
        }
        console.log('  ‚úÖ Questions updated');
      }

      if (followUps !== undefined) {
        console.log('  Updating', followUps.length, 'follow-ups...');
        // Delete existing follow-ups
        db.prepare('DELETE FROM follow_ups WHERE template_id = ?').run(req.params.id);
        // Insert new follow-ups
        if (followUps.length > 0) {
          const fStmt = db.prepare('INSERT INTO follow_ups (template_id, body, delay) VALUES (?, ?, ?)');
          followUps.forEach(f => {
            const body = f.body || f.text || f.Body || '';
            const delay = f.delay || f.Delay || 180;
            console.log('    Inserting follow-up:', body.substring(0, 50) + '...', 'delay:', delay);
            fStmt.run(req.params.id, body, delay);
          });
        }
        console.log('  ‚úÖ Follow-ups updated');
      }
    });

    updateTemplate();
    console.log('‚úÖ Template updated successfully');

    res.json({ message: 'Template updated successfully' });
  } catch (error) {
    console.log('‚ùå Error updating template:', error.message);
    res.status(500).json({ error: error.message });
  }
});

// Duplicate a strategy
router.post('/:id/duplicate', authenticateToken, (req, res) => {
  console.log('üìã POST /api/templates/:id/duplicate HIT');
  console.log('üìù Template ID:', req.params.id);
  console.log('üìù User ID:', req.user.id);
  console.log('üì¶ Custom name:', req.body.customName);

  try {
    const { customName } = req.body;
    const originalId = req.params.id;

    // Get the original strategy with all its data
    const original = db.prepare('SELECT * FROM templates WHERE id = ?').get(originalId);

    if (!original) {
      console.log('‚ùå Original template not found');
      return res.status(404).json({ error: 'Strategy not found' });
    }

    const newId = uuidv4();
    const now = new Date().toISOString();
    const newName = customName || `${original.name} (Copy)`;

    console.log('‚ú® Creating duplicate with ID:', newId);
    console.log('üìù New name:', newName);

    const duplicateTemplate = db.transaction(() => {
      // Create duplicate template
      db.prepare(`
        INSERT INTO templates (
          id, user_id, name, tag, bot_temperature, brief, resiliancy, booking_readiness,
          tone, initial_message, objective, company_information,
          message_delay_initial, message_delay_standard, cta, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `).run(
        newId,
        req.user.id,
        newName,
        `${original.tag}-copy`,
        original.bot_temperature,
        original.brief,
        original.resiliancy,
        original.booking_readiness,
        original.tone,
        original.initial_message,
        original.objective,
        original.company_information,
        original.message_delay_initial,
        original.message_delay_standard,
        original.cta,
        now,
        now
      );
      console.log('  ‚úÖ Template record duplicated');

      // Duplicate FAQs
      const faqs = db.prepare('SELECT * FROM faqs WHERE template_id = ?').all(originalId);
      if (faqs.length > 0) {
        console.log('  Duplicating', faqs.length, 'FAQs...');
        const faqStmt = db.prepare('INSERT INTO faqs (template_id, question, answer, delay) VALUES (?, ?, ?, ?)');
        faqs.forEach(faq => {
          faqStmt.run(newId, faq.question, faq.answer, faq.delay);
        });
        console.log('  ‚úÖ FAQs duplicated');
      }

      // Duplicate qualification questions
      const questions = db.prepare('SELECT * FROM qualification_questions WHERE template_id = ?').all(originalId);
      if (questions.length > 0) {
        console.log('  Duplicating', questions.length, 'questions...');
        const qStmt = db.prepare('INSERT INTO qualification_questions (template_id, text, conditions, delay) VALUES (?, ?, ?, ?)');
        questions.forEach(q => {
          qStmt.run(newId, q.text, q.conditions, q.delay);
        });
        console.log('  ‚úÖ Questions duplicated');
      }

      // Duplicate follow-ups
      const followUps = db.prepare('SELECT * FROM follow_ups WHERE template_id = ?').all(originalId);
      if (followUps.length > 0) {
        console.log('  Duplicating', followUps.length, 'follow-ups...');
        const fStmt = db.prepare('INSERT INTO follow_ups (template_id, body, delay) VALUES (?, ?, ?)');
        followUps.forEach(f => {
          fStmt.run(newId, f.body, f.delay);
        });
        console.log('  ‚úÖ Follow-ups duplicated');
      }

      // Duplicate custom actions
      const customActions = db.prepare('SELECT * FROM custom_actions WHERE template_id = ?').all(originalId);
      if (customActions.length > 0) {
        console.log('  Duplicating', customActions.length, 'custom actions...');
        customActions.forEach(action => {
          const actionStmt = db.prepare(`
            INSERT INTO custom_actions (template_id, action, rule_condition, description)
            VALUES (?, ?, ?, ?)
          `);
          const result = actionStmt.run(newId, action.action, action.rule_condition, action.description);
          const newActionId = result.lastInsertRowid;
          const oldActionId = action.id;

          // Duplicate action chains
          const chains = db.prepare('SELECT * FROM action_chains WHERE custom_action_id = ?').all(oldActionId);
          chains.forEach(chain => {
            const chainStmt = db.prepare(`
              INSERT INTO action_chains (custom_action_id, chain_name, chain_order)
              VALUES (?, ?, ?)
            `);
            const chainResult = chainStmt.run(newActionId, chain.chain_name, chain.chain_order);
            const newChainId = chainResult.lastInsertRowid;
            const oldChainId = chain.id;

            // Duplicate chain steps
            const steps = db.prepare('SELECT * FROM chain_steps WHERE chain_id = ?').all(oldChainId);
            steps.forEach(step => {
              db.prepare(`
                INSERT INTO chain_steps (chain_id, step_order, function, parameters)
                VALUES (?, ?, ?, ?)
              `).run(newChainId, step.step_order, step.function, step.parameters);
            });
          });
        });
        console.log('  ‚úÖ Custom actions duplicated');
      }
    });

    // Execute the transaction
    duplicateTemplate();

    // Get the complete duplicate with all nested data
    const duplicate = db.prepare('SELECT * FROM templates WHERE id = ?').get(newId);

    console.log('‚úÖ Strategy duplicated successfully');
    res.status(201).json({
      message: 'Strategy duplicated successfully',
      strategy: duplicate
    });

  } catch (error) {
    console.error('‚ùå Duplicate strategy error:', error);
    console.error('‚ùå Stack trace:', error.stack);
    res.status(500).json({ error: 'Failed to duplicate strategy' });
  }
});

// Delete template with proper cascade
router.delete('/:id', authenticateToken, (req, res) => {
  console.log('üóëÔ∏è DELETE /api/templates/:id HIT');
  console.log('üóëÔ∏è Deleting template for user:', req.user.id);
  console.log('üìù Template ID:', req.params.id);
  console.log('üìù ID type:', typeof req.params.id);

  const deleteTemplate = db.transaction((templateId) => {
    console.log('  üîÑ Transaction started - Deleting template:', templateId);
    
    // Temporarily disable foreign keys
    db.pragma('foreign_keys = OFF');
    
    try {
      // Delete all conversations and related data
      const conversations = db.prepare('SELECT id FROM conversations WHERE template_id = ?').all(templateId);
      
      conversations.forEach(conv => {
        db.prepare('DELETE FROM messages WHERE conversation_id = ?').run(conv.id);
        db.prepare('DELETE FROM scheduled_messages WHERE conversation_id = ?').run(conv.id);
      });
      
      db.prepare('DELETE FROM conversations WHERE template_id = ?').run(templateId);
      
      // Delete custom actions and chains
      const customActions = db.prepare('SELECT id FROM custom_actions WHERE template_id = ?').all(templateId);
      
      customActions.forEach(action => {
        const chains = db.prepare('SELECT id FROM action_chains WHERE custom_action_id = ?').all(action.id);
        
        chains.forEach(chain => {
          db.prepare('DELETE FROM chain_steps WHERE chain_id = ?').run(chain.id);
        });
        
        db.prepare('DELETE FROM action_chains WHERE custom_action_id = ?').run(action.id);
      });
      
      db.prepare('DELETE FROM custom_actions WHERE template_id = ?').run(templateId);
      
      // Delete template-related data
      db.prepare('DELETE FROM faqs WHERE template_id = ?').run(templateId);
      db.prepare('DELETE FROM qualification_questions WHERE template_id = ?').run(templateId);
      db.prepare('DELETE FROM follow_ups WHERE template_id = ?').run(templateId);
      
      // Delete the template (only if owned by user)
      const result = db.prepare('DELETE FROM templates WHERE id = ? AND user_id = ?').run(templateId, req.user.id);

      console.log('  ‚úÖ Delete result:', result);
      console.log('  üìä Rows affected:', result.changes);

      return result;
    } finally {
      // Re-enable foreign keys
      db.pragma('foreign_keys = ON');
    }
  });
  
  try {
    const result = deleteTemplate(req.params.id);

    if (result.changes === 0) {
      console.log('‚ö†Ô∏è Template not found or already deleted');
      return res.status(404).json({ error: 'Template not found' });
    }

    console.log('‚úÖ Template deleted successfully');
    res.json({ message: 'Template deleted successfully' });
  } catch (error) {
    console.error('‚ùå Delete error:', error);
    console.error('‚ùå Error stack:', error.stack);
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;